// Ignore Spelling: Metadata

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Resources;
using System.Text;
using System.Xml.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using AsyncIt;
using AsyncIt.Properties;




static class Parser
{


    const string singleIndent = "    ";
    public static (string header, string bodyIndent, string footer) GenerateSourceSkeleton(this TypeDeclarationSyntax type)
    {
        // not using Roslyn formatting because it  may introduce some unwanted performance overhead and new 
        // dependencies. Doing the formatting manually for a fully deterministic code generation like here
        // is an adequate approach.
        var header = new StringBuilder();
        var footer = new StringBuilder();

        var statements = new List<string>();

        var parent = type.Parent;

        while (parent != null)
        {
            if (parent is NamespaceDeclarationSyntax ns)
                statements.Add($"namespace {ns.Name}");

            if (parent is FileScopedNamespaceDeclarationSyntax fsns)
                statements.Add($"namespace {fsns.Name}");

            if (parent is TypeDeclarationSyntax ts)
            {
                var metadata = ts.GetMetadata();
                statements.Add($"{metadata.Modifiers} {metadata.Name}{metadata.GenericParameters}".TrimEnd());
            }

            parent = parent.Parent;
        }

        statements.Reverse();

        string indent = "";
        foreach (var item in statements)
        {
            header.AppendLine($"{indent}{item}")
                  .AppendLine($"{indent}{{");

            footer.InsertLine(0, $"{indent}}}");

            indent += singleIndent;

        }

        var hCode = header.ToString().TrimEnd();
        var fCode = footer.ToString().TrimEnd();

        return (hCode, indent, fCode);
    }


    public static Dictionary<string, string> GenerateSourceForTypes(this SyntaxTree syntaxTree, AsyncAttribute attribute = default)
    {
        var result = new Dictionary<string, string>();

        var types = syntaxTree.GetRoot().DescendantNodes().OfType<TypeDeclarationSyntax>();

        foreach (var type in types)
        {
            var info = GenerateExtensionSource(type, attribute ?? new AsyncAttribute());
            if (info.type != null)
                result.Add(info.type, info.code);
        }

        return result;
    }

    public static (string type, string code) GenerateExtensionSource(this TypeDeclarationSyntax type, AsyncAttribute attribute)
    {

        var code = new StringBuilder();
        var typeMetadata = type.GetMetadata();
        var methodsMetadata = type.Members.OfType<MethodDeclarationSyntax>()
            .Select(x => x.GetMetadata())
            .Where(x => !x.Attributes.Any(y => y.Contains("Ignore")) &&
                        (x.Modifiers.Contains("public") || x.Modifiers.Contains("internal")));

        if (!typeMetadata.Attributes.Any(x => x.Contains("Async")))
            return (null, null);

        code.AppendLine("// <auto-generated/>");

        foreach (var ns in typeMetadata.UsingNamespaces)
            code.AppendLine(ns);

        (var header, var indent, var footer) = type.GenerateSourceSkeleton();


        if (header.Any())
            code.AppendLine(header);

#pragma warning disable RS1035 // Do not use APIs banned for analyzers (Environment.NewLine)

        if (attribute.Algorithm == Algorithm.PartialType)
        {
            if (!typeMetadata.Modifiers.Contains("partial"))
                code.AppendLine($"#error For extending {typeMetadata.Name} members with `{nameof(Algorithm.PartialType)}` algorithm " +
                    $"you need to declared {typeMetadata.Name} as partial. " +
                    $"Alternatively you can specify different algorithm (e.g. {nameof(Algorithm.ExtensionMethods)} in the " +
                    $"`{nameof(AsyncAttribute)}` declaration). ");

            code.AppendLine($"{indent}{typeMetadata.Modifiers} {typeMetadata.Name}{typeMetadata.GenericParameters}".TrimEnd())
                .AppendLine($"{indent}{{");

            var methodsCode = new StringBuilder();
            foreach (MethodMetadata item in methodsMetadata)
            {
                var methodImplementation = "";
                switch (attribute.Interface)
                {
                    case Interface.Async:
                        methodImplementation = item.GenerateAsyncMethod();
                        break;
                    case Interface.Sync:
                        methodImplementation = item.GenerateSyncMethod();
                        break;
                    case Interface.Full:
                        methodImplementation = item.IsAsync()
                            ? item.GenerateSyncMethod()
                            : item.GenerateAsyncMethod();
                        break;
                }

                foreach (var line in methodImplementation.Split('\n'))
                    methodsCode.AppendLine($"{indent}{singleIndent}{line}");

                methodsCode.AppendLine();
            }
            code.AppendLine(methodsCode.ToString().TrimEnd());

            code.AppendLine($"{indent}}}");
        }
        else
        {
            code.AppendLine($"{indent}public static class {typeMetadata.Name}Extensions{typeMetadata.GenericParameters}".TrimEnd())
                .AppendLine($"{indent}{{");

            var methodsCode = new StringBuilder();
            foreach (MethodMetadata item in methodsMetadata)
            {
                var methodImplementation = "";
                switch (attribute.Interface)
                {
                    case Interface.Async:
                        methodImplementation = item.GenerateAsyncExtensionMethod(typeMetadata);
                        break;
                    case Interface.Sync:
                        methodImplementation = item.GenerateSyncExtensionMethod(typeMetadata);
                        break;
                    case Interface.Full:
                        methodImplementation = item.IsAsync()
                            ? item.GenerateSyncExtensionMethod(typeMetadata)
                            : item.GenerateAsyncExtensionMethod(typeMetadata);
                        break;
                }

                foreach (var line in methodImplementation.Split('\n'))
                    methodsCode.AppendLine($"{indent}{singleIndent}{line}");

                methodsCode.AppendLine();
            }
            code.AppendLine(methodsCode.ToString().TrimEnd());

            code.AppendLine($"{indent}}}");
        }
#pragma warning restore RS1035 // Do not use APIs banned for analyzers

        if (footer.Any())
            code.AppendLine(footer);

        return (typeMetadata.Name, code.ToString().TrimEnd());
    }

    public static string[] GetParentNamespaces(this TypeDeclarationSyntax type)
    {
        var namespaces = new List<string>();

        var parent = type.Parent;

        while (parent != null)
        {
            if (parent is NamespaceDeclarationSyntax ns)
                namespaces.Add(ns.Name.ToString());
            else if (parent is FileScopedNamespaceDeclarationSyntax ns1)
                namespaces.Add(ns1.Name.ToString());

            parent = parent.Parent;
        }

        namespaces.Reverse();

        return namespaces.ToArray();
    }

#pragma warning disable RS1035 // Do not use APIs banned for analyzers
    static string NewLine = Environment.NewLine;
#pragma warning restore RS1035 // Do not use APIs banned for analyzers

    public static TypeMetadata GetMetadata(this TypeDeclarationSyntax type)
    {
        var usingNamespaces = type.SyntaxTree.GetRoot()
                .DescendantNodes()
                .OfType<UsingDirectiveSyntax>()
                .Select(x => x.ToString())
                .ToArray();

        var tokens = type
            .ChildTokens()
            .Select(x => new { Text = x.ToString(), Element = (object)x, x.SpanStart })
            .Where(x => x.SpanStart < type.OpenBraceToken.SpanStart);

        var nodes = type
            .ChildNodes()
            .Select(x => new { Text = x.ToString(), Element = (object)x, x.SpanStart })
            .Where(x => x.SpanStart < type.OpenBraceToken.SpanStart);

        var all = nodes.Concat(tokens).OrderBy(x => x.SpanStart).ToList();

        var attributeList = all.TakeOutWhile(x => (x.Element is AttributeListSyntax)).Select(x => x.Element as AttributeListSyntax);
        var modifiers = all.TakeOutWhile(x => !x.Element.IsToken(SyntaxKind.IdentifierToken));
        var name = all.TakeOutFirst();
        var genericParameters = all;

        var metadata = new TypeMetadata();
        metadata.UsingNamespaces = usingNamespaces;
        metadata.Attributes = attributeList.GetAttributes();
        metadata.Modifiers = modifiers.Select(x => x.Text).JoinBy(" ");
        metadata.Name = name.Text;
        metadata.GenericParameters = genericParameters.Select(x => x.Text).JoinBy(" ");

        // var rawAttrNodes = attributeList.GetAttributeNodes();

        return metadata;
    }

    internal static string[] GetAttributes(this IEnumerable<AttributeListSyntax> attributeList)
        => attributeList.SelectMany(x => x.Attributes).Select(x => x.ToFullString()).ToArray();


    internal static object[] GetAttributeNodes(this IEnumerable<AttributeListSyntax> attributeList)
        => attributeList.SelectMany(x => x.Attributes).ToArray();


    public static MethodMetadata GetMetadata(this MethodDeclarationSyntax method)
    {
        var tokens = method
            .ChildTokens()
            .Select(x => new { Text = x.ToString(), Element = (object)x, x.SpanStart }).ToArray();

        var nodes = method
            .ChildNodes()
            .TakeWhile(p => !(p is BlockSyntax) && !(p is ArrowExpressionClauseSyntax))
            .Select(x => new { Text = x.ToString(), Element = (object)x, x.SpanStart });

        var all = nodes.Concat(tokens).OrderBy(x => x.SpanStart).ToList();

        // use TakeOutWhile to keep track of taken items

        var attributeList = all.TakeOutWhile(x => (x.Element is AttributeListSyntax)).Select(x => x.Element as AttributeListSyntax);
        var modifiers = all.TakeOutWhile(x => x.Element is SyntaxToken);
        var retureType = all.TakeOutFirst();
        var signature = all.TakeOutWhile(x => !(x.Element is ParameterListSyntax));
        var parameters = all.TakeOutFirst();
        var invokParameters = (parameters.Element as ParameterListSyntax).Parameters
                                                                         .Select(x => x.GetLastToken().Text);

        var metadata = new MethodMetadata();

        metadata.Attributes = attributeList.GetAttributes();
        metadata.Modifiers = modifiers.Select(x => x.Text).JoinBy(" ");
        metadata.ReturnType = retureType.Text;
        metadata.Name = signature.FirstOrDefault()?.Text;
        metadata.GenericParameters = signature.Skip(1).FirstOrDefault()?.Text;
        metadata.Parameters = parameters.Text;
        metadata.ParametersNames = $"({invokParameters.JoinBy(", ")})";

        return metadata;
    }
}
